# -*- coding: utf-8 -*-
"""AI-Assignment-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z_oFWs5Em-JimHNU8sbKznj7oQsDHfGf
"""

import matplotlib.pyplot as plt
import numpy as np
import matplotlib.patches as patches
import networkx as nx
from queue import PriorityQueue
import math

# Define the maze layout/state space
MAZE_MAP = {
    (0, 0): 'empty', (1, 0): 'empty', (2, 0): 'obstacle', (3, 0): 'empty', (4, 0): 'empty', (5, 0): 'entry',
    (0, 1): 'empty', (1, 1): 'empty', (2, 1): 'reward1', (3, 1): 'empty', (4, 1): 'trap1', (5, 1): 'empty',
    (0, 2): 'empty', (1, 2): 'trap2', (2, 2): 'empty', (3, 2): 'obstacle', (4, 2): 'empty', (5, 2): 'empty',
    (0, 3): 'empty', (1, 3): 'treasure', (2, 3): 'obstacle', (3, 3): 'empty', (4, 3): 'trap4', (5, 3): 'empty',
    (0, 4): 'empty', (1, 4): 'obstacle', (2, 4): 'empty', (3, 4): 'obstacle', (4, 4): 'treasure', (5, 4): 'reward1',
    (0, 5): 'reward2', (1, 5): 'empty', (2, 5): 'trap3', (3, 5): 'empty', (4, 5): 'empty', (5, 5): 'empty',
    (0, 6): 'empty', (1, 6): 'obstacle', (2, 6): 'obstacle', (3, 6): 'empty', (4, 6): 'trap3', (5, 6): 'empty',
    (0, 7): 'empty', (1, 7): 'obstacle', (2, 7): 'treasure', (3, 7): 'reward2', (4, 7): 'empty', (5, 7): 'empty',
    (0, 8): 'empty', (1, 8): 'empty', (2, 8): 'empty', (3, 8): 'trap1', (4, 8): 'obstacle', (5, 8): 'empty',
    (0, 9): 'empty', (1, 9): 'empty', (2, 9): 'treasure', (3, 9): 'empty', (4, 9): 'empty', (5, 9): 'empty',
}

# Determine grid dimensions.
rows = max(r for r, c in MAZE_MAP.keys()) + 1
cols = max(c for r, c in MAZE_MAP.keys()) + 1

print(f"Grid size: {rows} rows, {cols} columns derived from MAZE_MAP")

# Parameters for drawing the hexagonal grid.
hex_height = 1
hex_size = hex_height / np.sqrt(3)
hex_horiz_spacing = 1.5 * hex_size
hex_vert_spacing = hex_height

# Colors for visualization.
color_map = {
    'trap1': 'violet', 'trap2': 'plum', 'trap3': 'orchid', 'trap4': 'thistle',
    'reward1': 'lightgreen', 'reward2': 'darkgreen', 'treasure': 'gold',
    'obstacle': 'dimgray', 'empty': 'white', 'entry': 'skyblue'
}

# Convert (row, col) to node index.
def to_node(row, col):
    if not (0 <= row < rows and 0 < cols and 0 <= col < cols):
         return None
    return row * cols + col

# Convert node index to row and column
def to_grid(node):
     if node is None: return None
     if not (0 <= node < rows * cols):
         return None
     return node // cols, node % cols

# Setup plot.
fig, ax = plt.subplots(1)
ax.set_aspect('equal')

# Create graph.
G = nx.Graph()

# Draw maze cells and add nodes to graph
for row in range(rows):
    for col in range(cols):
        node = to_node(row, col)
        element = MAZE_MAP.get((row, col), 'empty')
        x = col * hex_horiz_spacing
        y = row * hex_vert_spacing
        if col % 2 == 1: # Offset odd columns
            y += hex_vert_spacing / 2
        G.add_node(node, pos=(x, y), element=element)
        color = color_map.get(element, 'gray')
        hexagon = patches.RegularPolygon((x, y), numVertices=6, radius=hex_size,
                                         orientation=np.radians(90), facecolor=color, edgecolor='black')
        ax.add_patch(hexagon)

# Adjust plot limits and add legend
ax.set_xlim(-hex_size, cols * hex_horiz_spacing + hex_size)
ax.set_ylim(-hex_size, rows * hex_vert_spacing + hex_size)
ax.axis('off')
legend_handles = [patches.Patch(color=color, label=label) for label, color in color_map.items()]
plt.legend(handles=legend_handles, loc='upper right', bbox_to_anchor=(1.15, 1))

# Define movement costs (penalties) for entering cell types
penalties = {
    'trap1': 4, 'trap2': 4, 'trap3': 4, 'trap4': 4,
    'reward1': 0.5, 'reward2': 0.5, 'treasure': 1,
    'obstacle': float('inf'), 'empty': 1, 'entry': 1
}

# Add edges to the graph based on hexagonal neighbors and penalties
for row in range(rows):
    for col in range(cols):
        current = to_node(row, col)
        current_element = MAZE_MAP.get((row, col), 'empty')
        if current_element == 'obstacle': continue # Obstacles have no exits

        # Define neighbors based on hex grid
        neighbors_coords = []
        neighbors_coords.append((row - 1, col)) # N
        neighbors_coords.append((row + 1, col)) # S
        neighbors_coords.append((row, col - 1)) # W
        neighbors_coords.append((row, col + 1)) # E
        if col % 2 == 0: # Even column diagonals
            neighbors_coords.append((row - 1, col - 1)) # NW
            neighbors_coords.append((row - 1, col + 1)) # NE
        else: # Odd column diagonals
            neighbors_coords.append((row + 1, col - 1)) # SW
            neighbors_coords.append((row + 1, col + 1)) # SE

        for nr, nc in neighbors_coords:
            if 0 <= nr < rows and 0 <= nc < cols:
                neighbor = to_node(nr, nc)
                neighbor_element = MAZE_MAP.get((nr, nc), 'empty')
                if neighbor_element != 'obstacle': # Only add edges to non-obstacles
                    weight = penalties.get(neighbor_element, 1) # Cost is neighbor's penalty
                    G.add_edge(current, neighbor, weight=weight)

# A* search algorithm
def a_star_search(graph, start, goal):
    if start is None or goal is None or start not in graph.nodes or goal not in graph.nodes or graph.nodes[start]['element'] == 'obstacle' or graph.nodes[goal]['element'] == 'obstacle':
        return [] # Invalid start/goal.

    open_set = PriorityQueue()
    open_set.put((0, start)) # (f_score, node)
    came_from = {}
    g_score = {node: float('inf') for node in graph.nodes}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph.nodes}
    f_score[start] = heuristic(start, goal)

    while not open_set.empty():
        current_f_score, current = open_set.get()
        if current_f_score > f_score[current]: continue

        if current == goal: return reconstruct_path(came_from, current)

        for neighbor in graph.neighbors(current):
            move_cost = graph.edges[current, neighbor].get('weight', 1)
            tentative_g_score = g_score[current] + move_cost
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)
                open_set.put((f_score[neighbor], neighbor))

    return [] # if goal unreachable

# Heuristic function: Euclidean distance between hex centers
def heuristic(node, goal):
    if node is None or goal is None or node not in G.nodes or goal not in G.nodes:
        return float('inf')
    pos1 = G.nodes[node]['pos']
    pos2 = G.nodes[goal]['pos']
    return np.sqrt((pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2)

# Reconstruct path from A* output
def reconstruct_path(came_from, current):
    total_path = [current]
    while current in came_from:
        current = came_from[current]
        total_path.append(current)
    return total_path[::-1] # Reverse to get start-to-goal path

# Plot the path on the maze visualization
def plot_path(graph, path):
    pos = nx.get_node_attributes(graph, 'pos')
    # Clear previous path drawing
    for line in ax.get_lines(): line.remove()
    for patch in ax.patches:
         if isinstance(patch, patches.Circle): patch.remove()

    # Draw circles on path nodes
    path_nodes_pos = [pos[node] for node in path if node in pos]
    for x, y in path_nodes_pos:
         circle = patches.Circle((x,y), radius=hex_size*0.4, color='orange', zorder=2)
         ax.add_patch(circle)
    plt.show()

# Find start and treasure nodes
entry_coords = next(((r, c) for (r, c), element in MAZE_MAP.items() if element == 'entry'), None)
start = to_node(*entry_coords) if entry_coords else None
if start is None: print("Error: Entry point not found.")

treasures_coords = [coord for coord, element in MAZE_MAP.items() if element == 'treasure']
treasures = [to_node(r, c) for r, c in treasures_coords]
if not treasures: print("No treasures found.")

print(f"Start node: {to_grid(start)}")
print(f"Treasure nodes: {[to_grid(t) for t in treasures]}")

# Simulate collecting all treasures. Agent goes to closest uncollected treasure using A*
def collect_all_treasures(start, treasures, graph):
    path = [start]
    current_position = start
    remaining_treasures = set(treasures) # Targets left to collect

    # Simulation state
    total_energy = 100
    total_steps = 0
    energy_multiplier = 1.0
    step_multiplier = 1.0

    # Main simulation loop: continues until treasures collected or failure
    while remaining_treasures:
        # Find the closest valid uncollected treasure as the next target
        valid_remaining_treasures = [t for t in remaining_treasures if t is not None and t in graph.nodes]
        if not valid_remaining_treasures:
            print("No valid remaining treasures found.")
            break

        closest_treasure = min(valid_remaining_treasures, key=lambda treasure: heuristic(current_position, treasure))
        print(f"Current position: {to_grid(current_position)}, Targeting closest treasure: {to_grid(closest_treasure)}")

        # Find path to the target using A*
        partial_path = a_star_search(graph, current_position, closest_treasure)
        if not partial_path:
            print(f"No path found from {to_grid(current_position)} to {to_grid(closest_treasure)}.")
            break # Cannot reach target, stop

        # Traverse the found path step by step.
        for next_node in partial_path[1:]:
            current_position = next_node # Move agent
            element = graph.nodes.get(current_position, {}).get('element', 'empty')
            if element is None: element = 'empty'

            print(f"  Moving to {to_grid(current_position)} ({element}). Energy: {total_energy}, Steps: {total_steps}")

            # Apply costs
            total_steps += step_multiplier
            total_energy -= energy_multiplier
            path.append(current_position) # Add step to path history

            # Apply cell effects
            if element == 'reward1': energy_multiplier = max(0.5, energy_multiplier / 2) # Halve energy cost
            elif element == 'reward2': step_multiplier = max(0.5, step_multiplier / 2) # Halve step cost
            elif element == 'trap1': energy_multiplier *= 2 # Double energy cost
            elif element == 'trap2': step_multiplier *= 2 # Double step cost
            elif element == 'trap3': # Teleport back 2 steps in path history
                print("  Entered Trap3. Moving back 2 steps.")
                if len(path) >= 3:
                    current_position = path[-3] # Set position to 3rd last node in path
                    path.append(current_position) # Add teleported position to path
                    print(f"  Teleported back to {to_grid(current_position)}.")
                else: print("  Not enough path history for Trap3 effect.")
            elif element == 'trap4': # Re-evaluates treasures based on visits
                print("  Entered Trap4. Re-evaluating remaining treasures.")
                visited_treasures_so_far = [t for t in treasures if t in path]
                # This logic effectively means only already visited treasures count
                remaining_treasures = set(visited_treasures_so_far) - set(path)
                return path, total_energy, total_steps # Exit early
            elif element == 'treasure': # Collect treasure if uncollected
                 if current_position in remaining_treasures:
                    remaining_treasures.remove(current_position)
                    print(f"  Collected Treasure! {len(remaining_treasures)} remaining.")

            # Check for energy depletion
            if total_energy <= 0:
                print("Ran out of energy!")
                return path, total_energy, total_steps # Exit when fail

    # Reached if all treasures collected
    if not remaining_treasures: print("All treasures collected!")

    return path, total_energy, total_steps # Return final results

# Run the simulation
treasure_path, remaining_energy, total_steps = collect_all_treasures(start, treasures, G)

print("\n--- Results ---")
print("Final Path (Grid Coords):", [to_grid(node) for node in treasure_path])
print("Final Remaining Energy:", remaining_energy)
print("Final Total Steps:", total_steps)
print("Number of unique nodes visited:", len(set(treasure_path)))

# Plot the final path
plot_path(G, treasure_path)

# Display plot
plt.show()

